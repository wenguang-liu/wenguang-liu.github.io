---
layout:     post
title:      (db)数据库事务管理（2）
subtitle:   串行化调度与锁模式
date:       2019-02-17
author:     Wenguangliu
header-img: img/post-bg-unix-linux.jpg
catalog: 	 true
tags:
    - 数据库
    - 事务
    - 串行化
    - 调度
    - 锁模式
    - 两阶段封锁
    - 共享锁
    - 排他锁
---

本文主要介绍数据库事务中的另外一个话题，即事务执行的串行化调度与锁模式。关于串行化调度，主要介绍串行化，冲突，优先图等概念与知识，以及基于锁的可串行化；在锁模式中，介绍各种锁的类型，包括：共享锁，排他锁，更新锁，增量锁等内容。

## 1.事务串行化调度
前面，我们提到，事务在执行时，如果能够保证事务之间“不耦合”（串行），那么是能够确保状态的一致性和正确性的。但是这样的性能会很低，在实际中，事务之间也是并发执行的，并发就会导致事务的错乱而产生结果与串行执行得到的结果不一样。为了解决这个问题，这里将介绍“可串行化调度”执行的得到的结果与完全串行调度时一样的动作序列。

### 1.1 串行调度与可串行调度
调度是对一个或多个事务的重要动作的一个序列。串行调度是将所有事务的动作按照事务进行归组，然后按照事务顺序一个个执行的方式，即先执行一个事务的所有动作，然后在执行下一个事务的所有动作。

例如，事务T1和T2如下：   
```
T1: R(A, t); t = 2 * t; W(A, t);   
T2: R(A, s); s = s + 10; W(A, s);   
```
那么如果按（T1，T2）顺序执行，则为 R(A, t); t = 2 * t; W(A, t); R(A, s); s = s + 10; W(A, s);   
如果按（T2, T1）顺序执行 ，则为 R(A, s); s = s + 10; W(A, s); R(A, t); t = 2 * t; W(A, t);   
假如A的初始值为5, 那么两个执行顺序得到最终值分别为： 5 * 2 + 10 = 20 和 (5 + 10) * 2 = 30， 因此我们可以看到对于数据库的最终状态与事务顺序有关；

穿行调度是能够确保数据库的一致性。除了串行调度外，实际上还存在其他一些能够确保数据库一致性状态的调度，这些调度称为可串行化调度。    
例如，对于以下事务T1和T2，   
```
T1: R(A, t); t = 2 * t; W(A, t); R(B, t); t = 2 * t; W(B, t);   
T2: R(A, s); s = s + 10; W(A, s); R(B, s); s = s + 10; W(B, s);  
```
假如初始状态A=B=5， 对于以上两个事务，对A和B执行相同的操作，根据一致性需要，A和B最终也需要相等。    
即对于串行事务（T1，T2），最终A = B = 20；对于串行事务（T2，T1），最终A=B=30；
而也存在非穿行事务，能够确保最终状态是一致的，如调度：    
```
R(A, t); t = 2 * t; W(A, t);    事务T1       
R(A, s); s = s + 10; W(A, s);   事务T2     
R(B, t); t = 2 * t; W(B, t);    事务T1  
R(B, s); s = s + 10; W(B, s);   事务T2    
```
最终的状态与调度（T1，T2）一致，这种调度称为可串行化调度。    
但并不是所有调度都是一致的，例如：    
```
R(A, t); t = 2 * t; W(A, t);    事务T1       
R(A, s); s = s + 10; W(A, s);   事务T2     
R(B, s); s = s + 10; W(B, s);   事务T2    
R(B, t); t = 2 * t; W(B, t);    事务T1  
```
最终得到A = 2 * 5 + 10 = 20，而B =(5 + 10) * 2 = 30。   

另外，事务的具体语义对调度也是有影响的，例如将上例中事务T1中的乘于改成加号，那么所有调度上例中非可串行化调度就会是一个可串行调度，但是在实际数据库中，数据库调度时并不会考虑语句的语义。

### 1.2 冲突可串行化与优先图


### 1.3 基于锁的可串行化 



## 2. 锁模式

### 2.1 共享锁

### 2.2 排他锁

### 2.3 更新锁

### 2.4 增量锁


## 3.总结