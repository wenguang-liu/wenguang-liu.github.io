---
layout:     post
title:      (db)数据库事务管理(3)
subtitle:   锁调度器与树形结构的锁策略
date:       2019-02-21
author:     Wenguangliu
header-img: img/post-bg-unix-linux.jpg
catalog: 	 true
tags:
    - 数据库
    - 事务
    - 调度器
    - 锁结构
    - 数据库元素结构
    - 树形协议
---

前面文章介绍了数据库事务中的串行化方法和锁模式，本文将继续前面的内容，介绍数据库中封锁的调度器，以及在应用锁时面对的问题，包括锁的数据结构，数据库元素的不同数据结构等。

## 1. 锁调度器
锁调度器的存在主要是以下原则规定的：事务自身不申请封锁，或不能依赖事务完成锁的管理；同时，事务也不会释放锁。而是锁调度器在数据访问动作中插入封锁的动作，在事务提交或中止时释放锁。

基于以上规则，我们可以定义锁的调度器主要如下图所示：   
![avatar](/asserts/database_transaction_1.png)

调度器维护着锁表，该锁表是一个独立的缓存，即后面将介绍的锁结构。
调度器有两个部分，并进行以下操作：
1. 第一部分接受事务产生的请求流，并在所有数据库访问中插入适当的锁动作；  
2. 第二部分接受第一部分传的封锁和数据库访问动作序列，并正确执行这些动作：在这里如果一个动作无法获得所需要的锁，那么该动作将会被推迟；如果能获得所有的锁，那么将按站如下进行：
	1. 如果是数据库访问，该动作将会被传至数据库执行引擎中进行执行；
	2. 如果是封锁动作，该动作将查看锁表以决定是否能被授予该数据元素的锁；
		1. 如果能，则修改锁表，并将该锁授予该事务；
		2. 如果不能，则需要在锁表中记录该锁已经被申请，并且该事务将会被scheduler2推迟，直至需要的锁被授予；
3. 事务T结束（提交或中止）时，事务管理器通知scheduler1，scheduler1将释放事务T所有锁；如果有事务等待这些锁，scheduler1将通知scheduler2；
4. scheduler2被通知某数据库元素上的锁被释放时，scheduler2决定下一个被授予该锁的事务；获得锁的事务将继续执行。

## 2. 锁表结构
简单地说，锁表结构就是数据库元素与该元素的封锁信息的一个映射，具体的数据结构如下：   
```
struct LockInfo {
	uint64_t element_id;
	GroupModel model;
};
struct GroupModel {
	int32_t lock_mode;
	bool waiting;
	LockTransaction* tx_list;
}

struct LockTransaction {
	uint64_t tx_id;
	int32_t lock_mode;
	bool waiting;
	LockTransaction* next_lock_same_trx;
	LockTransaction* next_lock_trx;
}

map<uint64_t, LockInfo*> full_lock_info;

```
在每一个元素的锁中，组模式描述了在申请该元素锁的新事务时面临的最高要求，这能够提升比较的速度。例如在共享-排他-更新模式中，S表示该元素只被持有共享锁，因此可以获得共享锁或更新锁；U表示被持有一个更新锁，但可能有共享锁，并拒绝任何封锁请求；X表示被持有排他锁，拒绝任何封锁请求。   
等待位（waiting）表示至少有一个事务在等待该锁；   
事务列表表示所有持有A的锁，或者在等待A上的锁的那些事务；

在封锁请求中，如果元素A不存在表锁中，相应的将会在表锁中创建，并根据不同的锁模式进行修改；在解锁请求中，将关于事务T持有的锁进行删除，并且如果该T持有的锁模式和组模式不同，将不需要修改组模式；否则需要重新计算当前的组模式。

如果在释放锁时，waiting位为true，那么需要将要把该锁授予锁列表中的一个或多个锁，一般可以有以下几种策略：先到先服务；共享锁优先；升级锁优先。

## 3. 数据库元素结构
在数据库中，数据库元素可以时不同粒度的，例如：元组、块、关系，这些数据元素是数据库中不同层次结构，如果给层次结构封锁是本节关注的内容。另外，并发控制系统中另外一中层次结构就是本身就被组织成一棵树的数据结构，例如B-树索引。  
在这里，可以有三个层次的数据库元素：关系，一个关系可以包含多个数据块，每一个数据块包含了多个元组。

解决不同粒度锁需要涉及另一种称为“警示锁”的新锁。在警示协议中，一个元素既包含“普通锁”，又包含“警示锁”。我们将在普通锁前面加“I”表示警示锁。在警示锁协议中需要遵循以下规则：
1. 在任何元素上加X或X锁时，需要从层次结构的根开始；   
2. 一直从根出发，直到找到需要封锁元素的位置，然后请求该元素上锁的授予；
3. 当需要封锁的元素位于当前元素的元素的下面，则在当前元素加上警示锁IS（S）或IX（X）；

在进行锁授予判断时，采用如下的相容性矩阵进行判断。   
		IS 		IX 		S 		X   
IS 		Y 		Y		Y		N   
IX 		Y 		Y		N 		N    
S 		Y 		N 		Y 		N    
X 		N 		N 		N 		N    

在表中，例如，当请求IS锁时，表示需要请求当前元素的下面的S锁，当前元素被IS（被授予下面元素的S锁），IX（被授予下面元素的X锁），S（被授予S锁），这几种情况都是没有冲突的；其他的也可以类似进行分析。

在以上封锁策略中，会存在幻象的现象，即例如，如下事务T1，读取表中某字段的长度总和，事务T2表示在表中插入一条记录。假如D1和D2是原来表中的记录，事务T2插入D3记录。那么在警示协议下，下面的调度是合法的：  
  r1(D1), r1(D2), w2(D3), w3(L)   
在这种情况下，L的长度不等于D1+D2+D3，而是D1+D2，但是实际上这三个记录是表真实存在的，这就是存在的幻象。   
避免这种现象也比较简单，只需要在关系表中进行的封排他锁。   

## 4. 锁的树形协议
在树形结构中，访问基本上从树根开始的，然后不断地向下进行访问，如果直接采用两阶段封锁策略，即从树根开始封锁，那么可用性会变得非常低，将并发度直接变成一。

为了解决这个问题，这里采用针对树形结构的特殊封锁协议，即：
1. 事务的第一个锁可以在任何结点上，实际上在B树中，第一个锁总是树根；   
2. 事务只有拥有父节点的锁时，才能够获得后续结点的锁；
3. 结点可以在任何时候解锁；
4. 事务不能够对已经解锁的结点进行二次上锁，即使仍然拥有父节点上的锁。

以上策略可以确保了事务在整个封锁过程中是从上往下的，并且事务之间是有序的，即加入事务T1和T2同时需要A、B结点的封锁，且A是B的前序节点，如果事务T1先获得A的封锁，那么它也一定先获得B的封锁。这就保证了事务的有序性和正确性。

## 5. 总结
本文介绍了基于锁的调度器和在使用锁时遇到的问题，包括了锁结构，针对特殊数据库元素的锁策略，即意向锁；在树形结构中应用的锁协议。

