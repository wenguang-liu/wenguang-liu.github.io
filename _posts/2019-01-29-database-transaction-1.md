---
layout:     post
title:      (db)数据库事务管理（5）
subtitle:   故障与日志策略
date:       2019-01-29
author:     Wenguangliu
header-img: img/post-bg-unix-linux.jpg
catalog: 	 true
tags:
    - 数据库
    - 故障
    - 日志
    - 事务
    - Redo日志
    - Undo日志
---

本文将开始介绍数据库管理系统中的故障以及应对策略。在数据库管理中，最常见的应对策略就是日志，通过Redo，Undo日志来维护数据库事务中出现的错误。   
本文首先将介绍数据库中常见的故障模式，然后介绍Undo日志，Redo日志，Redo/Undo日志，最后介绍应对故障的其他一些策略。

## 故障模式与事务
数据库中出现故障是常有的事情，这些问题大体可以分为：
- 错误数据输入： 用户将错误数据输入到数据库，违背了数据库的一致性。例如电话号码输错一位。一般采用约束和促发器识别这些错误。
- 介质故障： 硬盘的局部故障，例如改变了一位或几位，这种可以通过奇偶校验码进行检测和纠正；如果整个磁盘都损坏了，那么需要RAID，备份等途径进行恢复。
- 灾难性故障：是指外部如火灾，地震等造成的故障。面对这种故障一般采用分布备份方法进行预防和恢复。
- 系统故障：数据库中的事物是一步一步进行的，当进行到一半发生故障（如断电），会造成事物状态的丢失，造成数据的不一致。针对这种错误，则需要日志方法进行修复，也就是本文的重点。

数据库事务是数据库操作执行的单元，为了确保数据库数据的一致性，必须保证数据库事务具有：
- 原子性（Atomic）：即事务要么全部完成，要么像没有执行过一样，最终状态不能够时中间的某一个不合法的状态；
- 一致性（Consistency）：即事务执行前和执行后，均要满足数据库的数据一致性。例如，A向B转账100元，那么A的账户首先至少有100元的余额；在完成转账过程中，A的账户减少了100元，B的账户多了100元，满足全量不变性；
- 隔离性（Isolation）： 事务之间不能够影响，即事务之间的状态是不可见的。隔离性按照隔离粒度不同，可以分为：未提交读（READ UNCOMMITED），即事务能够读到其他事务中未提交的状态；提交读（READ COMMITTED）：基于锁机制的并发控制需要对选定对象的写锁一直保持到事物结束，但是读锁是操作后马上释放，因此可能出现“不可重复读”现象；可重复读（REPEATABLE READS）：即基于锁并发控制需要对选定对象的读锁和写锁均保持到事务结束，但不要求“范围锁”，所以可能出现“幻读”；可串行化（SERIABLE）：最高的隔离级别，在基于锁的并发控制中，除了要求选定对象上的读锁和写锁要保持到事务结束后才释放，并且在SELECT语句中WHERE子句描述一个范围时，应该获得一个“范围锁”，避免幻读。
- 持久性（Durability）：事务提交后，系统的状态时永久的。

因为在执行事务的过程中，可能因为操作自身原因或是外部原因，导致事务中止，从而使数据库处于不一致的状态。为了解决这个不一致，数据库系统需要Undo日志，Redo日志或两者来使数据恢复到一致状态。

首先看一下日志形式：
- <START T>: 事务T开始
- <COMMIT T>: 提交T
- <ABORT T>:事务T执行失败


## Undo日志
Undo日志就是用来撤销还没提交的执行语句产生的效果，以恢复数据库的状态。   
在Undo日志中，还会记录更新记录，即三元组：<T, X, v>，表示事务T对X修改之前的值为v；

### Undo日志规则
为了事务和缓冲区管理器能够根据Undo日志从故障中恢复，那么需要遵循一下两条规则：   
- 事务T修改了数据库元素X的值，那么日志三元组<T，X，v>的日志必须要在X的新值写入磁盘之前写到磁盘；
- 对于事务提交COMMIT日志，它必须要在事务改变的所有数据库元素写入到磁盘之后才写到磁盘中【尽快】；

以上也就是说，对于一个事务，需要按如下顺序写入磁盘：   
1. 指明改变数据库元素的日志记录；
2. 改变的数据库元素自身数据；
3. COMMIT日志记录；

### 使用Undo日志恢复
对于Undo日志而言，保留了完整的记录信息。当故障发生时，可以将Undo日志从头开始扫描，并将事务分成已完成的事务和未完成的事务。   
- 对于已完成的事务【有<START T>和<COMMIT T>的事务】，我们不需要做任何事情，因为根据以上的日志规则，能够保证数据已经落盘；   
- 对于未完成的事务【有 <START T> 但没有 <COMMIT T> 的事务】，我们需要对Undo日志进行相关处理，以恢复数据的一致性；    

对于未完成的事务，采用一下过程进行恢复：将日志从尾部开始扫描日志，在扫描过程中，记录所有有<COMMIT T>或<ABORT T>记录的事务；在扫描过程中，如果发现修改日志记录<T, X, v>，则：
- 如果事务T已有COMMIT记录，则不需要额外的操作，因为事务T已被提交；
- 否则，事务T未完成或中止，则需要将数据库中X的值改为v，以确保数据库的一致性；

### 检查点
对于直接使用Undo日志进行恢复，需要扫描整个完整的Undo日志，为了减少这种扫描的日志长度，可以对日志中加入检查点(CheckPoint)。

在一个检查点中，我们可以：
1. 系统暂停接受新的事务；
2. 等所有活跃的事务COMMIT或者ABORT，并将COMMIT/ABORT日志落盘；
3. 写入日志记录<CKPT>，并刷新日志；
4. 开始接受新的事务请求。

在恢复中，依然是从尾部开始扫描，处理方式同上，直到遇到一个<CKPT>日志，停止扫描。因为<CKPT>之前的所有事务均已经完成，不需要进行恢复。

这种方法的效率很低，如果在加入检查点时，正好有一个长事务，那么就会阻塞其他所有的事务。

为了避免这种情况，我们可以采用 非静态检查点的技术。非晶态检查点的过程包括：
1. 写入<START CKPT(T1,..., Tk)>并刷日志到硬盘，其中T1,...,Tk是当前所有活跃事务的标识符；
2. 等待T1,...，Tk事务完成，待完成后，写入日志记录<END CKPT>并刷日志；

在进行日志恢复的时候，可以分为以下两种情况：
- 先遇到<END CKPT>：那么所有未完成的事务均是在上一个<START CKPT>开始的，那么只需要从后扫描到上一个<START CKPT>便可停止；
- 先遇到<START CKPT(T1,...,Tk)>：那么没有办法确定T1,...,Tk的事务已经完成，而且上一个<START CKPT>开始的事务均可能未完成，因此扫描时需要扫描到上一个<START CKPT>。此外，为了降低扫描成本，我们还可以将同一事务的日志链到一起，方便查找日志。

### 一个例子


## Redo日志
所谓

## Redo/Undo日志


## 其他策略