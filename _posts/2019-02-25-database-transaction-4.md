---
layout:     post
title:      (db)数据库事务管理（4）
subtitle:   乐观的并发控制规则
date:       2019-02-25
author:     Wenguangliu
header-img: img/post-bg-unix-linux.jpg
catalog: 	 true
tags:
    - 数据库
    - 事务
    - 乐观
    - 调度器
    - 时间戳
    - 有效性确认
---

前面文章介绍了悲观调度--基于锁的串行化调度，本文将介绍两种乐观串行化调度策略，即基于时间戳的并发控制和基于有效性确认的并发控制。

## 1. 基于时间戳
基于时间戳的并发控制会为每一个事务分配一个“时间戳”，并且记录每个数据库元素上一次读和写访问的时间戳，对于当前事务的时间戳与元素的访问时间戳进行比较，确保实际调度是一个可串行化的调度。首先，将介绍一下时间戳的生成。
### 1.1 时间戳
时间戳通过以下方法产生：
1. 采用系统时间作为时间戳，只要确保调度器在一个时钟周期内调度两个以上事务的；
2. 采用计数器，单调递增，作为事务的逻辑时间戳；

为了使用时间戳进行并发控制，在每一个数据库元素上需要两个时间戳和一个提交位，即：
1. RT(X)，X最近一次被读取的时间戳；
2. WT(X)，X最近一次被写入的时间戳；
3. C(X)， X的提交位，表示最近一次X的修改是否已经被提交；该位主要目的是避免U对X进行修改，T读取X，而U最后被中止的情况；

### 1.2 存在问题
在基于时间戳的调度中，同样需要确保，最后事务的调度必须是它们串行化顺序。然而基于时间戳的方式中可能会存在一些问题。
1. 晚读：即事务先开始的师徒T在读数据库元素X时，X的写入时间在事务T开始之后，即TS(T) < WT(X)。原因可能是在T开始之后，U事务开始并且修改了X，然后T事务读取X；
2. 晚写：事务T先开始，然后事务U开始，并切读取了数据库元素X，然后事务T写入X，此时发生冲突，即：WT(X) < TS(T) < RT(X)。 TS(T) < RT(X)表明，事务T开始之后，有其他事务U读取了X；WT(X) < TS(T)表明没有其他事务写入X。

除了以上问题之外，基于时间戳的并发控制还会存在以下脏数据问题：
1. 假设事务T先开始，然后写入X，然后事务U开始，并读取数据X，最后事务T被中止。此时事务U读到X的数据是T写入的，但是事务T最后被回滚了，产生了脏读。为了解决这个问题，需要确保事务U的读推迟到T结束之后，可以根据提交位C(X)进行判断；
2. 假如事务T先开始，然后事务U开始，并写入X，然后事务T写入X，这时候将产生脏写。正确的做法是在T写入X时，什么也不做，确保数据的正确性。但是，如果最后U回滚了，那么X的值将被回滚到两个事务之前。为了解决这个问题，可以采用以下方法：当事务T写入X时，写到备份中而不是直接写入原值，并且在事务中止时可以撤回。提交位C（X）置为false，调度器保存X的旧值和原WT(X)的一个备份。

### 1.3 调度规则
为了解决以上存在的问题，作为事务的读写请求，调度器需要采取以下选择：a）同意请求; b) 中止事务，并以新时间戳重启；c) 推迟事务。

并且需要采取以下的规则：
1. 接收到请求 rT(X):
1.1 TS(X) >= WT(X)， 此读是可实现的：  
1.1.1 C(X)为true，同意请求，且 RT(X) = max (TS(X), RT(X));   
1.1.2 C(X)为false，推迟事务T，到C(X)为true或写X的事务中止；   
1.2 TS(X) <= WT(X)， 此读时不合法的，回滚事务T，并以新时间戳重启；   

2. 接收到请求 wT(X):
2.1 TS(T) >= RT(X)，并且TS(T) >= WT(X)，此写是合法的；
2.1.1 写入X；
2.1.2 WT(X) = TS(T);
2.1.3 C(X) = false;
2.2 TS(T) >= RT(X) 且 TS(T) < WT(X)，即此写是合法的，但是X已经由一个更晚的事务写入：
2.2.1 如果C(X)为true，那么将忽略T的写，
2.2.1 如果C(X)为false，那么将推迟事务T；
2.3 TS(T) < RT(X)，表明已经有一个更晚的事务读取过X，那么事务T是不可实现的，那么需要回滚事务T；

3. 接收到提交事务T请求：需要确认事务T所写入的所有数据库元素，并置C(X) = true，并促发依赖元素X的其他所有事务。

4. 接收到中止（回滚）事务T请求：等待事务T写入的元素的事务都将重试读或写，检查这些动作是否合法。

### 1.4 多版本时间戳
为了解决因为特殊情况而导致事务T中止，而不影响到其他事务，如1.2中最后一个问题，在写的时候不是直接写入X，而是创建一个新版本X，该模式下，与1.3存在以下不同的规则：
1. 有新的写入wT(X)时，如果合法，创建一个新版X(T)，其中，T=TS(X)；
2. 当有读rT(X)时，调度器找到X的版本X(t)，满足t<=TS(T)，且中间不存在其他的版本；
3. X的写时间与元素的版本相关；
4. 读时间与版本相关；
5. 版本数据清理，如果任何活跃时间的时间戳都大于版本X(T)的写时间时，可以删除X(T)之前的版本；

## 2. 基于有效性确认
与基于时间戳的并发控制不同，基于有效性确认的方法是维护活跃事务正在做什么的一个记录，在事务写入的一瞬间，需要经过“有效性确认阶段”，即将事务已读的、将写的元素与其他活跃事务的写集合做比较，如果存在事实上不可实现的行为，那么将回滚事务。

### 2.1 数据结构
对于每一个事务T，将维护读集合RS(T)和写集合WS(T)，并且将事务分成三个阶段：
1. 读。读取数据库中所有所需的元素RS(T)，并做相对应的计算；
2. 有效性确认。比较该事务与其他事务的读写集合确认事务T的有效性；
3. 写。经过有效性确认后，事务往数据库中写入其集合中元素的值；

此外，调度器还需要维护下面三个集合：
1. START，已经开始但未完成有效性确认的事务集合，并记录每个事务的开始时间START(T)；
2. VAL，已经确认但未完成的事务集合，并记录事务的开始时间START(T)和确认时间VAL(T)；
3. FIN，已经完成写阶段的事务，将记录事务的开始时间START(T)、确认时间VAL(T)和结束时间FIN(T)；

### 2.2 有效性确认规则
基于以上数据结构，调度器将根据这些数据做出正确的判断规则，具体如下：
1. 假如存在事务U，有：
1.1 U在VAL中，即事务U已经被确认；
1.2 FIN(U) > START(T)，事务T开始时，U未结束；
1.3 RS(T) and WS(U) 不为空；
以上将存在事务T在事务U开始，但是事务T可能读X在事务U写之前，存在事实上不可实现。即后开始的事务读到的值是旧值，此时需要将事务T进行回滚。
2. 稼穑事务U，有：
2.1 U在VAL中，U已经完成有效性确认；
2.2 FIN(U) > VAL(T), 事务T确认之前，事务U没有结束；
2.3 WS(T) and WS(U)不为空，如X；
以上条件下，如果确认事务T，那么事务T就可能在事务U之前写入X，而产生事实上不可实现，因此需要对T进行回滚。
以上两个条件是有效性确认必须要满足的规则。

## 3. 总结
这里将对封锁，时间戳，有效性确认三种并发控制进行简单分析总结。
封锁：在写冲突较多的时候，封锁具有更高的性能，因为封锁过程中，将推迟事务。但是封锁的锁空间与被封锁元素的个数成正比。
时间戳：乐观的并发控制在冲突较少时，即只读事务较多时性能较好。但是在高冲突情况下，将会产生大量的回滚，降低性能。同样地，所需的空间与数据库元素成正比，但是在一些实现中，往往将长时间不访问的看作是“最小时间戳”，可以对空间进行优化。
有效性确认：空间与当前活跃的事务成正比；且需要回滚时，相比于时间戳，有效性确认方法一般较晚。
