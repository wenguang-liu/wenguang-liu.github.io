---
layout:     post
title:      (db)数据库事务管理(5)
subtitle:   死锁检测与预防
date:       2019-03-02
author:     Wenguangliu
header-img: img/post-bg-unix-linux.jpg
catalog: 	 true
tags:
    - 数据库
    - 事务
    - 死锁
    - 等待图
    - 时间戳
    - 元素排列
---

前面几篇文章主要介绍了数据库事务执行相关的支持，包括日志，串行化调度，基于锁管理/时间戳/有效性确认的并发控制等。在高并发的数据库事务中，死锁是常见的。本文主要介绍解决死锁的方法。

## 1.死锁
在数据库高并发中，是容易发生死锁的。常见的死锁场景是两（多）个普通事务因为互相封锁了对方需要的资源；还有就是两（多）个事务将锁升级为排他锁能力的时候也可能导致死锁。

## 2.死锁检测
在本章节中，主要介绍死锁检测的方法，包括超时死锁检测和等待图死锁判断。  

### 2.1 超时死锁检测
超时死锁检测是最简单的检测方法，如果事务执行超过一定时间，那么就将该事务进行回滚。该方法主要存在的问题是不能便于定义超时时间，也可能造成非死锁的事务回滚。

### 2.2 等待图死锁检测
在锁表中，为每一个元素维护了等待X上的锁和X的封锁事务。
在等待图中，所有事务是一个结点，对于满足以下要求的事务U和事务T：U持有X上的锁；T等待X上的一个锁；除非U先释放持有X上的锁，否则T不能获得X上的封锁，那么存在 从T到U的弧。
如果等待图中不存在环，那么所有事务最终是能够完成的；但是如果图中有环，那么环中的事务将不能够继续向前，存在死锁。

## 3.死锁预防
死锁检测是事务在死锁发生时进行的，除了预防之外，我们还能够进行死锁预防。这里主要介绍 将数据元素有序锁的管理，和基于时间戳检测的死锁预防。

### 3.1 元素有序锁管理
将数据元素按照某种固定顺序进行排列，然后申请数据元素的锁都必须按照顺序进行，那么就不会产生由于事务等待图而导致的死锁。

### 3.2 时间戳检测死锁
基于时间戳进行死锁检测是将每一个事务与一个时间戳关联起来，该时间戳与基于时间戳并发控制不同，该时间戳仅用于死锁检测，且该时间戳在事务进行重置后仍不变。时间戳在事务T等待另一事务U持有的锁时，根据时间戳的大小可以有两种不同的方案。 

1. 等待-死锁方案：
如果事务T的时间戳比事务U小，那么允许事务T等待事务U持有的锁；
如果事务T的时间戳比事务U大，那么事务T“死亡”，T进行回滚；

2. 伤害-等待方案：
如果事务T的时间戳比事务U小，事务T“伤害”事务U，事务U必须回滚，并放弃事务T持有的锁；
如果事务T的时间戳比事务U大，那么事务T将等待事务U持有的锁；

在基于时间戳的两个方案中，时间戳较小的事务杀死了时间戳较大的事务，这就能保证，每一个事务能够变成系统中最老的事务而得到完成，保证“无饿死”。但是该方法可能会误操作（过预防），即将还没发生死锁的事务杀死。

## 4.总结
文本主要介绍了死锁检测的方法。其中这几种方法来说，相比于构造等待图，基于时间戳的检测方法更易实现。而等待图能完全确认死锁的发生与否，而不会产生误判。
